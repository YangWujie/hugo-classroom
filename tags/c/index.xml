<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on H@pPY</title>
    <link>http://yangwujie.github.io/hugo-classroom/tags/c/</link>
    <description>Recent content in C on H@pPY</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 30 May 2022 09:19:36 +0800</lastBuildDate><atom:link href="http://yangwujie.github.io/hugo-classroom/tags/c/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>File</title>
      <link>http://yangwujie.github.io/hugo-classroom/slides/c/file/</link>
      <pubDate>Mon, 30 May 2022 09:19:36 +0800</pubDate>
      
      <guid>http://yangwujie.github.io/hugo-classroom/slides/c/file/</guid>
      <description>C文件输入输出   文件无处不住，这包括你的头文件，你的源程序文件，编译生成的目标文件，链接得到的可执行文件 不涉及文件操作的C程序几乎不存在 即便那个最简单的Hello World程序也涉及文件操作，只不过穿了个马甲   printf就是个穿了马甲的文件操作
#include &amp;lt;stdio.h&amp;gt; int main() { 	printf(&amp;#34;Hello World!\n&amp;#34;); 	return 0; }  马甲之下的真相：
#include &amp;lt;stdio.h&amp;gt; int main() { 	fprintf(stdout, &amp;#34;Hello World!\n&amp;#34;); 	return 0; } 这个程序和原来的Hello World程序等价。
 标准输出设备  stdout即标准输出设备，程序运行时系统自动为你打开 除了stdout之外，系统还自动打开了stdin（标准输入设备）和stderr（标准错误设备） 文件、设备、流几个术语在某些场合下经常互换使用   int printf ( const char *format, ... ); int fprintf( FILE *stream, const char *format, ... ); 看了它们的函数原型，了解它们为什么有那样的名字了吧？
 stream − This is the pointer to a FILE object that identifies the stream.</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://yangwujie.github.io/hugo-classroom/slides/c/hello-world/</link>
      <pubDate>Sun, 29 May 2022 16:30:51 +0800</pubDate>
      
      <guid>http://yangwujie.github.io/hugo-classroom/slides/c/hello-world/</guid>
      <description>Hello World in C
及C程序的编译和链接过程
 hello.c
#include &amp;lt;stdio.h&amp;gt; int main() { 	printf(&amp;#34;Hello World!\n&amp;#34;); 	return 0; }  yang@ubuntu:~$ gcc hello.c -o hello yang@ubuntu:~$ ./hello Hello World! yang@ubuntu:~$  建造程序：gcc hello.c -o hello 运行程序：./hello 运行结果：$ Hello World!   Why do you need ./ (dot-slash) before executable or script name to run it in bash?
 建造（Build）过程含多个步骤   预处理   编译   链接    预处理  预处理的主要任务   纳入头文件（#include）   宏扩展（#define）   条件编译（#ifdef）    一个虚构的例子</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://yangwujie.github.io/hugo-classroom/posts/2022/05/hello-world/</link>
      <pubDate>Fri, 27 May 2022 15:45:18 +0800</pubDate>
      
      <guid>http://yangwujie.github.io/hugo-classroom/posts/2022/05/hello-world/</guid>
      <description>&lt;p&gt;用C语言写的&lt;code&gt;Hello World!&lt;/code&gt;程序。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
